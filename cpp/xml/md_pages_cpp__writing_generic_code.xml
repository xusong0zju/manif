<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="md_pages_cpp__writing_generic_code" kind="page">
    <compoundname>md_pages_cpp_Writing_generic_code</compoundname>
    <title>Writing generic code</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><itemizedlist>
<listitem><para><ulink url="#writing-generic-code">Writing generic code</ulink><itemizedlist>
<listitem><para><ulink url="#examples">Examples</ulink><itemizedlist>
<listitem><para><ulink url="#small-example">Small example</ulink></para>
</listitem><listitem><para><ulink url="#multiple-templated-arguments">Multiple templated arguments</ulink></para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para>All Lie group classes defined in <computeroutput>manif</computeroutput> have in common that they inherit from a templated base class. Therefore, template-based generic code can be written - similarly to Eigen.</para>
<sect1 id="md_pages_cpp__writing_generic_code_1autotoc_md12">
<title>Examples</title>
<sect2 id="md_pages_cpp__writing_generic_code_1autotoc_md13">
<title>Small example</title>
<para>Let us write a simple function that take any group object and prints some information about it,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;manif/manif.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">manif;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Derived&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>LieGroupBase&lt;Derived&gt;&amp;<sp/>g)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Degrees<sp/>of<sp/>freedom:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>g::DoF<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Underlying<sp/>representation<sp/>vector<sp/>size:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>g::RepSize<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Current<sp/>values:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>g<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n;</highlight></codeline>
<codeline><highlight class="stringliteral">}</highlight></codeline>
<codeline><highlight class="stringliteral"></highlight></codeline>
<codeline><highlight class="stringliteral">int<sp/>main()</highlight></codeline>
<codeline><highlight class="stringliteral">{</highlight></codeline>
<codeline><highlight class="stringliteral"><sp/><sp/>SE2d<sp/>p_2d;</highlight></codeline>
<codeline><highlight class="stringliteral"><sp/><sp/>print(p_2d);</highlight></codeline>
<codeline><highlight class="stringliteral"></highlight></codeline>
<codeline><highlight class="stringliteral"><sp/><sp/>SE3d<sp/>p_3d;</highlight></codeline>
<codeline><highlight class="stringliteral"><sp/><sp/>print(p_3d);</highlight></codeline>
<codeline><highlight class="stringliteral">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_pages_cpp__writing_generic_code_1autotoc_md14">
<title>Multiple templated arguments</title>
<para>Let us write a function that takes two group objects and performs some computation,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;manif/manif.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">manif;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>DerivedA,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>DerivedB&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>DerivedA::Scalar</highlight></codeline>
<codeline><highlight class="normal">ominusSquaredWeightedNorm(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>LieGroupBase&lt;DerivedA&gt;&amp;<sp/>state,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>LieGroupBase&lt;DerivedB&gt;&amp;<sp/>state_other</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(state-state_other).squaredWeightedNorm();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SE2d<sp/>state<sp/>=<sp/>SE2d::Random();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SE2d::DataType<sp/>state_other_data<sp/>=<sp/>SE2d::DataType::Random();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Eigen::Map&lt;SE2d&gt;<sp/>state_other_map(state_other_data.data());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>osn<sp/>=<sp/>ominusSquaredWeightedNorm(state,<sp/>state_other_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="pages/cpp/Writing-generic-code.md"/>
  </compounddef>
</doxygen>
